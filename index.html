<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Load vs Paint Timing</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <h1>Image Load vs Paint Timing Demo</h1>
    <p>This demo shows the difference between when images finish loading and when they are painted to the screen.</p>
    
    <div class="controls">
        <label for="image-size">Image Size:</label>
        <select id="image-size">
            <option value="small">Small (faster)</option>
            <option value="medium" selected>Medium</option>
            <option value="large">Large (slower)</option>
        </select>
        
        <label for="image-type">Image Type:</label>
        <select id="image-type">
            <option value="standard">Standard</option>
            <option value="lowquality">Low Quality First</option>
        </select>
        
        <button id="run-test">Run Test</button>
    </div>
    
    <div class="product-container" id="product-container"></div>
    
    <div id="results">
        <h2>Timing Results</h2>
        <p>Click "Run Test" to start...</p>
    </div>
    
    <div id="page-metrics">
        <h2>Page Performance Metrics</h2>
        <div id="page-metrics-content">
            <p>Waiting for metrics...</p>
        </div>
    </div>
    
    <div class="info-section">
        <h3>Viewport Detection Debug</h3>
        <p>This section displays real-time viewport detection data to help debug across different devices.</p>
        <div id="viewport-debug">
            <div>
                <h4>Device Information</h4>
                <pre id="device-info">Loading device info...</pre>
            </div>
            <div>
                <h4>Viewport Dimensions</h4>
                <pre id="viewport-dimensions">Loading viewport dimensions...</pre>
            </div>
            <div>
                <h4>Element Position Data</h4>
                <pre id="element-positions">No elements tracked yet</pre>
            </div>
            <div>
                <h4>IntersectionObserver Events</h4>
                <pre id="intersection-events">No intersection events yet</pre>
            </div>
        </div>
        <button id="refresh-debug">Refresh Debug Data</button>
    </div>
    
    <div class="info-section">
        <h3>About Page Performance</h3>
        <p><strong>First Contentful Paint (FCP):</strong> Marks when the first text or image is painted.</p>
        <p><strong>Largest Contentful Paint (LCP):</strong> Marks when the largest content element is painted.</p>
        <p><strong>Safari Compatibility:</strong> LCP doesn't work natively in Safari, so we use a fallback detection mechanism.</p>
        <p><strong>InViewport Logic:</strong> We use these calculations to determine if an element is in the viewport:</p>
        <pre>
// Check if element is in viewport
isInViewport = (
    rect.top < viewportHeight &&  // Element's top edge is above the bottom of viewport
    rect.bottom > 0 &&            // Element's bottom edge is below the top of viewport
    rect.left < viewportWidth &&  // Element's left edge is before right edge of viewport
    rect.right > 0                // Element's right edge is after left edge of viewport
);
        </pre>
    </div>
    
    <!-- Configuration -->
    <script>
    /**
     * Configuration constants for the image loading demo
     */
    const CONFIG = {
        // Product data
        products: [
            {
                title: "Premium Product One",
                description: "High-quality product with amazing features.",
                price: "$129.99"
            },
            {
                title: "Deluxe Product Two",
                description: "Exclusive design with premium materials.",
                price: "$149.99"
            },
            {
                title: "Ultimate Product Three",
                description: "The best in its category, unmatched quality.",
                price: "$199.99"
            }
        ],
        
        // Image size configuration
        imageSizes: {
            small: "200/150",
            medium: "600/400",
            large: "1200/800"
        },
        
        // Low quality image size
        lqipSize: "50/30",
        
        // Performance thresholds (in milliseconds)
        performance: {
            fcp: {
                good: 1800,
                poor: 3000
            },
            lcp: {
                good: 2500,
                poor: 4000
            },
            loadToPaint: {
                fast: 50,
                slow: 300
            }
        }
    };
    </script>
    
    <!-- Load the modules -->
    <script src="metrics.js"></script>
    <script src="imageLoader.js"></script>
    <script src="display.js"></script>
    
    <!-- Initialize the application -->
    <script>
    document.addEventListener('DOMContentLoaded', function() {
        // Wait slightly to ensure scripts are loaded
        setTimeout(function() {
            // Initialize Safari LCP polyfill
            initSafariLCPPolyfill();
            
            // Initialize page metrics tracking
            if (window.PageMetricsTracker) {
                window.pageMetricsTracker = new window.PageMetricsTracker();
                window.pageMetricsTracker.init();
            } else {
                console.error("PageMetricsTracker not found! Check that metrics.js is loaded correctly.");
            }
            
            // Create image loader instance
            if (window.ImageLoader) {
                const imageLoader = new window.ImageLoader();
                
                // Initialize display manager
                if (window.DisplayManager) {
                    window.displayManager = new window.DisplayManager(imageLoader);
                }
                
                // Event listener for the test button
                const runTestButton = document.getElementById('run-test');
                if (runTestButton) {
                    runTestButton.addEventListener('click', () => {
                        // Store current settings in session storage to preserve them
                        const imageSize = document.getElementById('image-size').value || 'medium';
                        const imageType = document.getElementById('image-type').value || 'standard';
                        
                        sessionStorage.setItem('savedImageSize', imageSize);
                        sessionStorage.setItem('savedImageType', imageType);
                        
                        // Force a complete page reload, bypassing the cache
                        window.location.reload(true);
                    });
                }
                
                // Check for saved settings from previous session
                const savedSize = sessionStorage.getItem('savedImageSize');
                const savedType = sessionStorage.getItem('savedImageType');
                
                if (savedSize && document.getElementById('image-size')) {
                    document.getElementById('image-size').value = savedSize;
                }
                
                if (savedType && document.getElementById('image-type')) {
                    document.getElementById('image-type').value = savedType;
                }
                
                // Clear saved settings now that we've used them
                sessionStorage.removeItem('savedImageSize');
                sessionStorage.removeItem('savedImageType');
                
                // Initial load
                imageLoader.loadImages();
                
                // Export for console debugging
                window.debugImageLoader = imageLoader;
            } else {
                console.error("ImageLoader not found! Check that imageLoader.js is loaded correctly.");
            }
        }, 300); // Delay to ensure scripts are fully loaded
    });
    
/**
 * Final approach: Unified Timing LCP Implementation
 * This implementation uses a shared timing reference for all measurements
 * to ensure consistency between LCP and paint times
 */
function initSafariLCPPolyfill() {
    // Check if we need a polyfill (Safari)
    const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    const needsPolyfill = isSafari && (!window.PerformanceObserver || 
        (() => {
            try {
                const testObserver = new PerformanceObserver(() => {});
                testObserver.observe({ type: 'largest-contentful-paint', buffered: true });
                testObserver.disconnect();
                return false; // No need for polyfill
            } catch (e) {
                return true; // Needs polyfill
            }
        })());
    
    if (needsPolyfill) {
        console.log('Safari detected! Initializing unified timing LCP polyfill');
        
        // Create a global timing reference instead of using performance.now directly
        // This ensures all timing mechanisms use the same reference point
        const timingReference = {
            // Store all paint events in a central location
            paintEvents: {},
            
            // Function to get elapsed time from navigation start
            getTime: function() {
                return performance.now();
            },
            
            // Record a paint event
            recordPaint: function(elementId, type, metadata = {}) {
                const time = this.getTime();
                
                if (!this.paintEvents[elementId]) {
                    this.paintEvents[elementId] = [];
                }
                
                const event = {
                    time,
                    type,
                    ...metadata
                };
                
                this.paintEvents[elementId].push(event);
                console.log(`[${time.toFixed(2)}ms] Recorded ${type} for ${elementId}`, metadata);
                
                return time;
            },
            
            // Get paint time for an element
            getPaintTime: function(elementId, type = null) {
                if (!this.paintEvents[elementId]) return null;
                
                if (type) {
                    // Find specific type
                    const event = this.paintEvents[elementId].find(e => e.type === type);
                    return event ? event.time : null;
                } else {
                    // Get latest paint time
                    const events = this.paintEvents[elementId];
                    return events.length > 0 ? events[events.length - 1].time : null;
                }
            },
            
            // Get all paint events
            getAllPaintEvents: function() {
                return this.paintEvents;
            }
        };
        
        // Make the timing reference globally available
        window.lcpTimingReference = timingReference;
        
        // ------ Modify the ImageLoader to use our unified timing ------
        
        // Store original monitorPaintTime function
        const originalMonitorPaintTime = window.ImageLoader.prototype.monitorPaintTime;
        
        // Override the monitorPaintTime function to use our unified timing
        window.ImageLoader.prototype.monitorPaintTime = function(img, index, loadTime, type = 'standard') {
            // Call the original implementation
            originalMonitorPaintTime.call(this, img, index, loadTime, type);
            
            // Add our unified timing implementation
            const elementId = `img-${index}`;
            
            // Record the load time
            timingReference.recordPaint(elementId, 'load', {
                index,
                loadTime,
                type
            });
            
            const originalWidth = img.offsetWidth;
            const originalHeight = img.offsetHeight;
            let paintDetected = false;
            
            const checkPaint = () => {
                if (!paintDetected && (img.offsetWidth !== originalWidth || img.offsetHeight !== originalHeight || img.naturalWidth > 0)) {
                    const paintTime = timingReference.recordPaint(elementId, 'paint', {
                        index,
                        originalWidth,
                        originalHeight,
                        newWidth: img.offsetWidth,
                        newHeight: img.offsetHeight,
                        naturalWidth: img.naturalWidth,
                        naturalHeight: img.naturalHeight,
                        type
                    });
                    
                    paintDetected = true;
                    
                    // Use this paint event for LCP if applicable
                    updateLCPIfLargest(img, paintTime);
                    
                    return;
                }
                
                if (!paintDetected) {
                    requestAnimationFrame(checkPaint);
                }
            };
            
            requestAnimationFrame(checkPaint);
        };
        
        // ------ LCP Detection with unified timing ------
        
        // Store the largest element seen so far
        let largestElement = null;
        let largestSize = 0;
        let largestTime = 0;
        
        // Function to check if an element is potentially the LCP
        function updateLCPIfLargest(element, time = null) {
            if (!element || !element.isConnected) return false;
            
            try {
                // Get element dimensions
                const rect = element.getBoundingClientRect();
                const area = rect.width * rect.height;
                
                // Check if it's in viewport
                const isInViewport = (
                    rect.top < window.innerHeight &&
                    rect.bottom > 0 &&
                    rect.left < window.innerWidth &&
                    rect.right > 0
                );
                
                // For images, only consider if they're loaded
                if (element.tagName === 'IMG' && (!element.complete || !element.naturalWidth)) {
                    return false;
                }
                
                // Only track elements that are in viewport and visible
                if (isInViewport && area > largestSize) {
                    // Use time parameter if provided, otherwise get current time
                    const eventTime = time || timingReference.getTime();
                    
                    largestSize = area;
                    largestElement = element;
                    largestTime = eventTime;
                    
                    // Record element ID for tracking
                    const elementId = element.dataset.index 
                        ? `img-${element.dataset.index}`
                        : `element-${Math.random().toString(36).substring(2, 9)}`;
                    
                    // Record this as an LCP event
                    timingReference.recordPaint(elementId, 'lcp', {
                        element: element.tagName,
                        class: element.className,
                        size: area,
                        time: eventTime
                    });
                    
                    // Update LCP metric
                    if (window.pageMetricsTracker && window.pageMetricsTracker.metrics) {
                        window.pageMetricsTracker.metrics.webVitals.lcp = {
                            value: eventTime,
                            element: element.tagName,
                            elementId: element.id,
                            elementClass: element.className,
                            size: area,
                            url: element.tagName === 'IMG' ? element.src : null,
                            renderTime: eventTime,
                            rating: window.pageMetricsTracker.getRating(eventTime, CONFIG.performance.lcp),
                            method: 'unified-timing'
                        };
                        
                        window.pageMetricsTracker.displayMetrics();
                    }
                    
                    console.log(`[${eventTime.toFixed(2)}ms] New LCP: ${element.tagName}${element.className ? '.' + element.className.replace(/\s+/g, '.') : ''} (${area} pixels)`);
                    return true;
                }
                
                return false;
            } catch (e) {
                console.error('Error in updateLCPIfLargest:', e);
                return false;
            }
        }
        
        // Function to scan the document for potential LCP elements
        function scanForLargestElement() {
            // Prioritize checking product images first
            const productImgs = Array.from(document.querySelectorAll('.product-image'));
            const otherImgs = Array.from(document.querySelectorAll('img:not(.product-image)'));
            const headings = Array.from(document.querySelectorAll('h1, h2'));
            const containers = Array.from(document.querySelectorAll('.product-item, main, article'));
            
            // Combined list prioritizing images
            const candidates = [...productImgs, ...otherImgs, ...headings, ...containers];
            
            // Check each candidate
            let updated = false;
            candidates.forEach(element => {
                if (updateLCPIfLargest(element)) {
                    updated = true;
                }
            });
            
            return updated;
        }
        
        // Check immediately
        setTimeout(scanForLargestElement, 0);
        
        // Set up checks after DOM and images load
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(scanForLargestElement, 50);
        });
        
        window.addEventListener('load', () => {
            setTimeout(scanForLargestElement, 100);
            setTimeout(scanForLargestElement, 500);
        });
        
        // Listen for image loads to update LCP
        document.addEventListener('load', (event) => {
            if (event.target.tagName === 'IMG') {
                setTimeout(() => {
                    updateLCPIfLargest(event.target);
                }, 50);
            }
        }, true);
        
        // Do periodic scans for late-loading content
        [200, 500, 1000, 2000].forEach(delay => {
            setTimeout(scanForLargestElement, delay);
        });
        
        // Create special monitor for product images
        function monitorProductImages() {
            document.querySelectorAll('.product-image').forEach(img => {
                if (img.dataset.lcpMonitored) return;
                img.dataset.lcpMonitored = true;
                
                const elementId = `img-${img.dataset.index}`;
                
                // Function to check for paint
                function checkImagePaint() {
                    if (img.complete && img.naturalWidth > 0) {
                        const time = timingReference.recordPaint(elementId, 'product-paint', {
                            index: img.dataset.index,
                            width: img.width,
                            height: img.height,
                            natural: `${img.naturalWidth}x${img.naturalHeight}`
                        });
                        
                        // Update LCP if this is largest
                        updateLCPIfLargest(img, time);
                    } else {
                        // Check again in next frame
                        requestAnimationFrame(checkImagePaint);
                    }
                }
                
                // Start monitoring
                if (img.complete) {
                    checkImagePaint();
                } else {
                    img.addEventListener('load', checkImagePaint);
                }
            });
        }
        
        // Set up product image monitoring
        if (document.readyState !== 'loading') {
            monitorProductImages();
        } else {
            document.addEventListener('DOMContentLoaded', monitorProductImages);
        }
        
        // Also monitor after load
        window.addEventListener('load', monitorProductImages);
        
        // Add a final analysis after all checks
        setTimeout(() => {
            console.log('--- Final LCP Analysis ---');
            console.log('Largest Element:', largestElement ? {
                tagName: largestElement.tagName,
                className: largestElement.className,
                size: largestSize,
                time: largestTime.toFixed(2) + 'ms'
            } : 'None found');
            
            console.log('All paint events:', timingReference.getAllPaintEvents());
            
            // Display unified timing data in page for debugging
            if (window.pageMetricsTracker && window.pageMetricsTracker.metrics) {
                const lcpInfo = window.pageMetricsTracker.metrics.webVitals.lcp;
                if (lcpInfo) {
                    lcpInfo.debug = {
                        usedUnifiedTiming: true,
                        paintEvents: timingReference.getAllPaintEvents()
                    };
                    
                    // Update display
                    window.pageMetricsTracker.displayMetrics();
                }
            }
        }, 3000);
    }
}
    </script>
</body>
</html>