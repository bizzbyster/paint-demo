<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Load vs Paint Timing</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <h1>Image Load vs Paint Timing Demo</h1>
    <p>This demo shows the difference between when images finish loading and when they are painted to the screen.</p>
    
    <div class="controls">
        <label for="image-size">Image Size:</label>
        <select id="image-size">
            <option value="small">Small (faster)</option>
            <option value="medium" selected>Medium</option>
            <option value="large">Large (slower)</option>
        </select>
        
        <label for="image-type">Image Type:</label>
        <select id="image-type">
            <option value="standard">Standard</option>
            <option value="lowquality">Low Quality First</option>
        </select>
        
        <button id="run-test">Run Test</button>
    </div>
    
    <div class="product-container" id="product-container"></div>
    
    <div id="results">
        <h2>Timing Results</h2>
        <p>Click "Run Test" to start...</p>
    </div>
    
    <div id="page-metrics">
        <h2>Page Performance Metrics</h2>
        <div id="page-metrics-content">
            <p>Waiting for metrics...</p>
        </div>
    </div>
    
    <div class="info-section">
        <h3>Viewport Detection Debug</h3>
        <p>This section displays real-time viewport detection data to help debug across different devices.</p>
        <div id="viewport-debug">
            <div>
                <h4>Device Information</h4>
                <pre id="device-info">Loading device info...</pre>
            </div>
            <div>
                <h4>Viewport Dimensions</h4>
                <pre id="viewport-dimensions">Loading viewport dimensions...</pre>
            </div>
            <div>
                <h4>Element Position Data</h4>
                <pre id="element-positions">No elements tracked yet</pre>
            </div>
            <div>
                <h4>IntersectionObserver Events</h4>
                <pre id="intersection-events">No intersection events yet</pre>
            </div>
        </div>
        <button id="refresh-debug">Refresh Debug Data</button>
    </div>
    
    <div class="info-section">
        <h3>About Page Performance</h3>
        <p><strong>First Contentful Paint (FCP):</strong> Marks when the first text or image is painted.</p>
        <p><strong>Largest Contentful Paint (LCP):</strong> Marks when the largest content element is painted.</p>
        <p><strong>Safari Compatibility:</strong> LCP doesn't work natively in Safari, so we use a fallback detection mechanism.</p>
        <p><strong>InViewport Logic:</strong> We use these calculations to determine if an element is in the viewport:</p>
        <pre>
// Check if element is in viewport
isInViewport = (
    rect.top < viewportHeight &&  // Element's top edge is above the bottom of viewport
    rect.bottom > 0 &&            // Element's bottom edge is below the top of viewport
    rect.left < viewportWidth &&  // Element's left edge is before right edge of viewport
    rect.right > 0                // Element's right edge is after left edge of viewport
);
        </pre>
    </div>
    
    <!-- Configuration -->
    <script>
    /**
     * Configuration constants for the image loading demo
     */
    const CONFIG = {
        // Product data
        products: [
            {
                title: "Premium Product One",
                description: "High-quality product with amazing features.",
                price: "$129.99"
            },
            {
                title: "Deluxe Product Two",
                description: "Exclusive design with premium materials.",
                price: "$149.99"
            },
            {
                title: "Ultimate Product Three",
                description: "The best in its category, unmatched quality.",
                price: "$199.99"
            }
        ],
        
        // Image size configuration
        imageSizes: {
            small: "200/150",
            medium: "600/400",
            large: "1200/800"
        },
        
        // Low quality image size
        lqipSize: "50/30",
        
        // Performance thresholds (in milliseconds)
        performance: {
            fcp: {
                good: 1800,
                poor: 3000
            },
            lcp: {
                good: 2500,
                poor: 4000
            },
            loadToPaint: {
                fast: 50,
                slow: 300
            }
        }
    };
    </script>
    
    <!-- Load the modules -->
    <script src="metrics.js"></script>
    <script src="imageLoader.js"></script>
    <script src="display.js"></script>
    
    <!-- Initialize the application -->
    <script>
    document.addEventListener('DOMContentLoaded', function() {
        // Wait slightly to ensure scripts are loaded
        setTimeout(function() {
            // Initialize Safari LCP polyfill
            initSafariLCPPolyfill();
            
            // Initialize page metrics tracking
            if (window.PageMetricsTracker) {
                window.pageMetricsTracker = new window.PageMetricsTracker();
                window.pageMetricsTracker.init();
            } else {
                console.error("PageMetricsTracker not found! Check that metrics.js is loaded correctly.");
            }
            
            // Create image loader instance
            if (window.ImageLoader) {
                const imageLoader = new window.ImageLoader();
                
                // Initialize display manager
                if (window.DisplayManager) {
                    window.displayManager = new window.DisplayManager(imageLoader);
                }
                
                // Event listener for the test button
                const runTestButton = document.getElementById('run-test');
                if (runTestButton) {
                    runTestButton.addEventListener('click', () => {
                        // Store current settings in session storage to preserve them
                        const imageSize = document.getElementById('image-size').value || 'medium';
                        const imageType = document.getElementById('image-type').value || 'standard';
                        
                        sessionStorage.setItem('savedImageSize', imageSize);
                        sessionStorage.setItem('savedImageType', imageType);
                        
                        // Force a complete page reload, bypassing the cache
                        window.location.reload(true);
                    });
                }
                
                // Check for saved settings from previous session
                const savedSize = sessionStorage.getItem('savedImageSize');
                const savedType = sessionStorage.getItem('savedImageType');
                
                if (savedSize && document.getElementById('image-size')) {
                    document.getElementById('image-size').value = savedSize;
                }
                
                if (savedType && document.getElementById('image-type')) {
                    document.getElementById('image-type').value = savedType;
                }
                
                // Clear saved settings now that we've used them
                sessionStorage.removeItem('savedImageSize');
                sessionStorage.removeItem('savedImageType');
                
                // Initial load
                imageLoader.loadImages();
                
                // Export for console debugging
                window.debugImageLoader = imageLoader;
            } else {
                console.error("ImageLoader not found! Check that imageLoader.js is loaded correctly.");
            }
        }, 300); // Delay to ensure scripts are fully loaded
    });
    
/**
 * Enhanced Safari LCP Polyfill
 * This provides more accurate LCP detection for Safari and other browsers that don't support the LCP API
 */
function initSafariLCPPolyfill() {
    // Check if we need a polyfill (Safari)
    const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    const needsPolyfill = isSafari && (!window.PerformanceObserver || 
        (() => {
            try {
                const testObserver = new PerformanceObserver(() => {});
                testObserver.observe({ type: 'largest-contentful-paint', buffered: true });
                testObserver.disconnect();
                return false; // No need for polyfill
            } catch (e) {
                return true; // Needs polyfill
            }
        })());
    
    if (needsPolyfill) {
        console.log('Safari detected! Initializing robust LCP polyfill');
        
        // Track the largest element seen so far - using a closure to maintain state
        let largestElement = null;
        let largestSize = 0;
        let updateCount = 0;
        
        // Function to safely get element dimensions
        function getElementVisibleSize(el) {
            if (!el || !el.isConnected) return 0;
            
            try {
                const rect = el.getBoundingClientRect();
                if (!rect.width || !rect.height) return 0;
                
                // For images, only count if they're loaded
                if (el.tagName === 'IMG') {
                    if (!el.complete || !el.naturalWidth) return 0;
                    
                    // Use natural dimensions for more accuracy with responsive images
                    const displayRatio = Math.min(1, rect.width / el.naturalWidth, rect.height / el.naturalHeight);
                    return el.naturalWidth * el.naturalHeight * displayRatio * displayRatio;
                }
                
                // Calculate visible area (intersection with viewport)
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                
                const visibleLeft = Math.max(0, rect.left);
                const visibleRight = Math.min(viewportWidth, rect.right);
                const visibleTop = Math.max(0, rect.top);
                const visibleBottom = Math.min(viewportHeight, rect.bottom);
                
                const visibleWidth = Math.max(0, visibleRight - visibleLeft);
                const visibleHeight = Math.max(0, visibleBottom - visibleTop);
                
                return visibleWidth * visibleHeight;
            } catch (e) {
                console.error('Error calculating element size:', e);
                return 0;
            }
        }
        
        // More accurate function to find largest content element
        function findLargestContentElement() {
            updateCount++;
            
            // Element selectors in order of LCP priority
            const candidateSelectors = [
                // Images are typically the LCP element
                '.product-image', // Specific product images
                'img[src*="picsum"]', // Image service images
                'img', // Any images
                
                // Large text elements
                'h1', '.hero-text', '.headline',
                
                // Video thumbnails and media
                'video', 'picture', 'svg',
                
                // Large content containers
                '.product-item', '.card', 'main', 'article',
                
                // Fallback to generic large elements
                'div', 'section'
            ];
            
            let candidates = [];
            
            // Build candidate list from selectors
            candidateSelectors.forEach(selector => {
                try {
                    const elements = document.querySelectorAll(selector);
                    if (elements.length > 0) {
                        candidates = [...candidates, ...Array.from(elements)];
                    }
                } catch (e) {
                    console.warn(`Error selecting "${selector}":`, e);
                }
            });
            
            // Deduplicate candidates
            candidates = [...new Set(candidates)];
            
            // Track whether we found a new largest element
            let foundNewLargest = false;
            let largestCandidate = null;
            let largestCandidateSize = 0;
            
            // Evaluate candidates
            candidates.forEach(el => {
                const size = getElementVisibleSize(el);
                
                // Adjustment factors - prioritize certain elements
                let adjustedSize = size;
                
                // Prioritize images slightly since they're usually the true LCP
                if (el.tagName === 'IMG') {
                    adjustedSize *= 1.2; // 20% priority boost for images
                }
                
                // Extra boost for product images
                if (el.classList.contains('product-image')) {
                    adjustedSize *= 1.1; // Additional 10% boost for product images
                }
                
                // Track candidate with largest adjusted size
                if (adjustedSize > largestCandidateSize) {
                    largestCandidateSize = adjustedSize;
                    largestCandidate = el;
                }
                
                // Only update global largest if raw size is larger
                if (size > largestSize) {
                    largestSize = size;
                    largestElement = el;
                    foundNewLargest = true;
                }
            });
            
            // Debug output
            if (updateCount <= 2 || foundNewLargest) {
                if (largestCandidate) {
                    console.log(`Safari LCP iteration ${updateCount}:`, {
                        selectedElement: largestElement?.tagName,
                        selectedElementClass: largestElement?.className,
                        selectedElementSize: largestSize,
                        largestCandidate: largestCandidate?.tagName,
                        largestCandidateClass: largestCandidate?.className,
                        largestCandidateSize: largestCandidateSize
                    });
                }
            }
            
            // Update LCP metric if we found a valid element
            if (foundNewLargest && largestElement && largestSize > 0) {
                updateLCPMetric(largestElement, largestSize);
            }
            
            return foundNewLargest;
        }
        
        // Function to update the LCP metric
        function updateLCPMetric(element, size) {
            if (!window.pageMetricsTracker || !window.pageMetricsTracker.metrics) return;
            
            const now = performance.now();
            
            window.pageMetricsTracker.metrics.webVitals.lcp = {
                value: now,
                element: element.tagName,
                elementId: element.id || null,
                elementClass: element.className || null,
                size: size,
                url: element.tagName === 'IMG' ? element.src : null,
                renderTime: now,
                rating: window.pageMetricsTracker.getRating(now, CONFIG.performance.lcp),
                method: 'enhanced-fallback'
            };
            
            window.pageMetricsTracker.displayMetrics();
        }
        
        // Schedule multiple checks to catch elements as they load
        // Immediate check
        setTimeout(() => {
            findLargestContentElement();
        }, 50);
        
        // Check after initial layout
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(() => {
                findLargestContentElement();
            }, 100);
        });
        
        // More thorough check after window load
        window.addEventListener('load', () => {
            // First check right after load
            setTimeout(() => {
                findLargestContentElement();
            }, 200);
            
            // Second check a bit later to catch any delayed renders
            setTimeout(() => {
                findLargestContentElement();
            }, 1000);
        });
        
        // Listen for image loads specifically
        document.addEventListener('load', (event) => {
            if (event.target.tagName === 'IMG') {
                // Check after a short delay to allow painting
                setTimeout(() => {
                    findLargestContentElement();
                }, 200);
            }
        }, true);
        
        // Periodic checks to catch late-loading content
        const checkIntervals = [500, 1000, 2000, 3000];
        checkIntervals.forEach(interval => {
            setTimeout(() => {
                findLargestContentElement();
            }, interval);
        });
    }
}
    </script>
</body>
</html>